// Autogenerated code from https://app.quicktype.io using a real response from the coinbase API.
// I used a real resposne because the json example response from the API docs did not work.

// To parse this JSON data, do
//
//     final coinbaseAccounts = coinbaseAccountsFromJson(jsonString);

import 'dart:convert';

CoinbaseAccounts coinbaseAccountsFromJson(String str) => CoinbaseAccounts.fromJson(json.decode(str));

String coinbaseAccountsToJson(CoinbaseAccounts data) => json.encode(data.toJson());

class CoinbaseAccounts {
    CoinbaseAccounts({
        this.pagination,
        this.data,
        this.warnings,
    });

    Pagination pagination;
    List<Datum> data;
    List<Warning> warnings;

    factory CoinbaseAccounts.fromJson(Map<String, dynamic> json) => CoinbaseAccounts(
        pagination: Pagination.fromJson(json["pagination"]),
        data: List<Datum>.from(json["data"].map((x) => Datum.fromJson(x))),
        warnings: List<Warning>.from(json["warnings"].map((x) => Warning.fromJson(x))),
    );

    Map<String, dynamic> toJson() => {
        "pagination": pagination.toJson(),
        "data": List<dynamic>.from(data.map((x) => x.toJson())),
        "warnings": List<dynamic>.from(warnings.map((x) => x.toJson())),
    };
}

class Datum {
    Datum({
        this.id,
        this.name,
        this.primary,
        this.type,
        this.currency,
        this.balance,
        this.createdAt,
        this.updatedAt,
        this.resource,
        this.resourcePath,
        this.allowDeposits,
        this.allowWithdrawals,
    });

    String id;
    String name;
    bool primary;
    DatumType type;
    Currency currency;
    Balance balance;
    DateTime createdAt;
    DateTime updatedAt;
    Resource resource;
    String resourcePath;
    bool allowDeposits;
    bool allowWithdrawals;

    factory Datum.fromJson(Map<String, dynamic> json) => Datum(
        id: json["id"],
        name: json["name"],
        primary: json["primary"],
        type: datumTypeValues.map[json["type"]],
        currency: Currency.fromJson(json["currency"]),
        balance: Balance.fromJson(json["balance"]),
        createdAt: DateTime.parse(json["created_at"]),
        updatedAt: DateTime.parse(json["updated_at"]),
        resource: resourceValues.map[json["resource"]],
        resourcePath: json["resource_path"],
        allowDeposits: json["allow_deposits"],
        allowWithdrawals: json["allow_withdrawals"],
    );

    Map<String, dynamic> toJson() => {
        "id": id,
        "name": name,
        "primary": primary,
        "type": datumTypeValues.reverse[type],
        "currency": currency.toJson(),
        "balance": balance.toJson(),
        "created_at": createdAt.toIso8601String(),
        "updated_at": updatedAt.toIso8601String(),
        "resource": resourceValues.reverse[resource],
        "resource_path": resourcePath,
        "allow_deposits": allowDeposits,
        "allow_withdrawals": allowWithdrawals,
    };
}

class Balance {
    Balance({
        this.amount,
        this.currency,
    });

    String amount;
    String currency;

    factory Balance.fromJson(Map<String, dynamic> json) => Balance(
        amount: json["amount"],
        currency: json["currency"],
    );

    Map<String, dynamic> toJson() => {
        "amount": amount,
        "currency": currency,
    };
}

class Currency {
    Currency({
        this.code,
        this.name,
        this.color,
        this.sortIndex,
        this.exponent,
        this.type,
        this.addressRegex,
        this.assetId,
        this.slug,
        this.clutter,
        this.destinationTagName,
        this.destinationTagRegex,
    });

    String code;
    String name;
    String color;
    int sortIndex;
    int exponent;
    CurrencyType type;
    String addressRegex;
    String assetId;
    String slug;
    String clutter;
    String destinationTagName;
    String destinationTagRegex;

    factory Currency.fromJson(Map<String, dynamic> json) => Currency(
        code: json["code"],
        name: json["name"],
        color: json["color"] == null ? null : json["color"],
        sortIndex: json["sort_index"],
        exponent: json["exponent"],
        type: currencyTypeValues.map[json["type"]],
        addressRegex: json["address_regex"],
        assetId: json["asset_id"],
        slug: json["slug"],
        clutter: json["clutter"] == null ? null : json["clutter"],
        destinationTagName: json["destination_tag_name"] == null ? null : json["destination_tag_name"],
        destinationTagRegex: json["destination_tag_regex"] == null ? null : json["destination_tag_regex"],
    );

    Map<String, dynamic> toJson() => {
        "code": code,
        "name": name,
        "color": color == null ? null : color,
        "sort_index": sortIndex,
        "exponent": exponent,
        "type": currencyTypeValues.reverse[type],
        "address_regex": addressRegex,
        "asset_id": assetId,
        "slug": slug,
        "clutter": clutter == null ? null : clutter,
        "destination_tag_name": destinationTagName == null ? null : destinationTagName,
        "destination_tag_regex": destinationTagRegex == null ? null : destinationTagRegex,
    };
}

enum CurrencyType { CRYPTO }

final currencyTypeValues = EnumValues({
    "crypto": CurrencyType.CRYPTO
});

enum Resource { ACCOUNT }

final resourceValues = EnumValues({
    "account": Resource.ACCOUNT
});

enum DatumType { WALLET }

final datumTypeValues = EnumValues({
    "wallet": DatumType.WALLET
});

class Pagination {
    Pagination({
        this.endingBefore,
        this.startingAfter,
        this.previousEndingBefore,
        this.nextStartingAfter,
        this.limit,
        this.order,
        this.previousUri,
        this.nextUri,
    });

    dynamic endingBefore;
    dynamic startingAfter;
    dynamic previousEndingBefore;
    String nextStartingAfter;
    int limit;
    String order;
    dynamic previousUri;
    String nextUri;

    factory Pagination.fromJson(Map<String, dynamic> json) => Pagination(
        endingBefore: json["ending_before"],
        startingAfter: json["starting_after"],
        previousEndingBefore: json["previous_ending_before"],
        nextStartingAfter: json["next_starting_after"],
        limit: json["limit"],
        order: json["order"],
        previousUri: json["previous_uri"],
        nextUri: json["next_uri"],
    );

    Map<String, dynamic> toJson() => {
        "ending_before": endingBefore,
        "starting_after": startingAfter,
        "previous_ending_before": previousEndingBefore,
        "next_starting_after": nextStartingAfter,
        "limit": limit,
        "order": order,
        "previous_uri": previousUri,
        "next_uri": nextUri,
    };
}

class Warning {
    Warning({
        this.id,
        this.message,
        this.url,
    });

    String id;
    String message;
    String url;

    factory Warning.fromJson(Map<String, dynamic> json) => Warning(
        id: json["id"],
        message: json["message"],
        url: json["url"],
    );

    Map<String, dynamic> toJson() => {
        "id": id,
        "message": message,
        "url": url,
    };
}

class EnumValues<T> {
    Map<String, T> map;
    Map<T, String> reverseMap;

    EnumValues(this.map);

    Map<T, String> get reverse {
        if (reverseMap == null) {
            reverseMap = map.map((k, v) => new MapEntry(v, k));
        }
        return reverseMap;
    }
}
